# Configurações do HubControl
# Copie este arquivo para .env e ajuste as configurações

# Configurações básicas
DEBUG=true
LOG_LEVEL=INFO
LOG_FILE=./logs/hubcontrol.log

# Configurações do banco de dados
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/hubcontrol

# Configurações de segurança
SECRET_KEY=your-secret-key-change-in-production

# Configurações do Google Cloud (opcional)
GOOGLE_PROJECT_ID=your-project-id
GOOGLE_APPLICATION_CREDENTIALS=./credentials/service-account.json
BIGQUERY_DATASET=hubcontrol
VERTEX_AIProjeto: Health Score CX — pt-BR, tema escuro (Firebase)

Objetivo
- App com duas áreas e controle de acesso por função (via Firebase Auth + custom claims):
  - Área do **Assessor** → somente **formulário** para registrar avaliações (escala 1–5 nas 8 dimensões). **Sem acesso** a dados, tabelas, painéis ou métricas.
  - Área de **CS/Diretoria/Admin** → dashboard analítico (médias, séries, heatmap, exportações) e CRUDs.
- Performance: suportar **200+ clientes**, **20+ assessores** e **10k+ avaliações**.

================================
DESIGN / TEMA (sem Figma)
================================
Aplique estes design tokens (Tailwind/variáveis CSS) em botões, links, cards, gráficos e fundos:
--primary:   #F22987;
--secondary: #5F328C;
--tertiary:  #0D6BA6;
--accent:    #6ACED9;
--dark:      #0D0D0D;   // superfície principal dos cards
--bg:        #0a0a0a;   // background global
--surface:   var(--dark);
--surface-2: #141414;
--text:      #E6E8EA;
--text-muted:#A3A8AD;
--border:    #1A1A1A;
--radius-xl: 16px;
--radius-2xl:20px;

Diretrizes de UI
- Tema escuro; cards 16–20px com sombras suaves; foco visível; skeletons de loading.
- Botões primários = var(--primary); hover/active 10–15% mais escuro; bordas var(--border).
- Inputs com labels claros, validação em tempo real e mensagens de erro legíveis.
- Datas em dd/mm/aaaa; textos em pt-BR.

================================
REQUISITOS NÃO-FUNCIONAIS
================================
- Paginação com Firestore (limit/orderBy/startAfter) + **lista virtualizada** nas tabelas extensas.
- Busca/autocomplete com **debounce ≈250ms**.
- Filtros globais propagados por **querystring** (URL) para compartilhar visões.
- **Exportações CSV/XLSX geradas no servidor** (Cloud Functions), arquivo em Cloud Storage + **URL assinada**.
- Uso de **Cloud Functions** para: criação atômica de avaliações, agregações, exportações e set de roles (custom claims).
- Criar **índices compostos do Firestore** (ver seção “Índices Firestore”).

================================
STACK / PERSISTÊNCIA (Firebase)
================================
- Front-end: **React + TypeScript + Tailwind** (padrão Lovable).
- **Firebase Auth** (email/senha). Armazenar **role** em custom claims e também em `profiles/{uid}`.
- **Cloud Firestore** como banco principal.
- **Cloud Functions** (Node) para lógica de servidor (criar avaliação, agregados, export).
- **Cloud Storage** para arquivos de exportação.

================================
MODELO DE DADOS (Firestore)
================================
Coleções (documentos de exemplo):

profiles/{uid}:
  - nome: string
  - role: 'assessor' | 'cs' | 'diretoria' | 'admin'   // espelho das custom claims
  - createdAt: timestamp

clients/{clientId}:
  - nome: string
  - nome_insensitivo: string  // nome em minúsculas e sem acento, para prefix-search
  - empresa: string
  - email: string
  - telefone: string
  - createdAt: timestamp

assessors/{assessorId}:
  - userId: string (uid do Firebase Auth)  // 1:1 com o usuário assessor
  - nome: string
  - email: string
  - ativo: boolean (default true)
  - createdAt: timestamp

dimensions/{dimensionId}:
  - slug: string (único)
  - label: string
  - ordem: number

evaluations/{evaluationId}:
  - clientId: string (ref clients)
  - assessorId: string (ref assessors)
  - assessorUid: string (Auth UID do assessor)
  - dataAvaliacao: timestamp/date (data da avaliação)
  - observacoes: string
  - mediaAvaliacao: number (média das 8 notas, 2 casas)
  - createdAt: timestamp
  - responses (subcoleção): responses/{dimensionId}
      - score: number (1..5)

monthly_aggregates/{docId} (pré-calculado p/ performance):
  - mes: string (ex: '2025-08')
  - clientId?: string
  - assessorId?: string
  - mediasPorDimensao: { [dimensionSlug]: number }
  - mediaGeral: number
  - totalAvaliacoes: number
  - updatedAt: timestamp

Seed de **dimensions** na ordem:
1) aprofunda-processos — “Aprofunda processos”
2) interesse-genuino — “Interesse genuíno”
3) comunicacao-ativa — “Comunicação ativa”
4) clareza-objetivos — “Clareza de objetivos”
5) aceita-implementa-sugestoes — “Aceita/Implementa sugestões”
6) condicoes-financeiras — “Condições financeiras”
7) equipe-estrutura — “Equipe/Estrutura”
8) maturidade-processos — “Maturidade p/ processos”

================================
CONTROLE DE ACESSO (UI) — FORM-ONLY PARA ASSESSOR
================================
- Guardas de rota por custom claims (`role`):
  - Se role === 'assessor': qualquer rota ≠ **/avaliar** → redirecionar para **/avaliar**.
  - Se role ∈ {'cs','diretoria','admin'}: rota padrão = **/painel**.
- Menu:
  - Assessor: mostrar apenas **“Avaliar”** e **“Sair”**.
  - Staff (cs/diretoria/admin): **“Painel”**, **“Clientes”**, **“Assessores”**, **“Dimensões”**, **“Sair”**.
- Camada de serviços: **não** carregar listagens/consultas de dados quando role === 'assessor'.

================================
REGRAS DE SEGURANÇA (Firestore Rules v2)
================================
Gerar o arquivo de **Rules** com a seguinte lógica (o código pode ser embutido/exibido no README e publicado):

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function signedIn() { return request.auth != null; }
    function hasRole(r) { return signedIn() && request.auth.token.role == r; }
    function isStaff() {
      return signedIn() && (request.auth.token.role in ['cs','diretoria','admin']);
    }
    function isAdmin() { return signedIn() && request.auth.token.role == 'admin'; }
    function isAssessor() { return signedIn() && request.auth.token.role == 'assessor'; }

    match /profiles/{uid} {
      allow read, update: if signedIn() && request.auth.uid == uid;
      allow create: if signedIn();
    }

    match /dimensions/{id} {
      allow read: if signedIn();         // necessário para montar o formulário
      allow write: if isAdmin();
    }

    match /clients/{id} {
      allow read, list: if isStaff();    // assessor não lê clients (usa função de busca)
      allow create, update: if isAdmin() || (signedIn() && request.auth.token.role == 'cs');
      allow delete: if isAdmin();
    }

    match /assessors/{id} {
      allow read: if isStaff() || (isAssessor() && resource.data.userId == request.auth.uid);
      allow create, update, delete: if isAdmin();
    }

    // Avaliações: leitura só staff; escrita via Cloud Function (ver abaixo).
    match /evaluations/{evalId} {
      allow read, list: if isStaff();
      allow create, update, delete: if false; // negar do cliente; usar Cloud Function (Admin SDK)
      match /responses/{respId} {
        allow read, list: if isStaff();
        allow create, update, delete: if false;
      }
    }

    match /monthly_aggregates/{docId} {
      allow read, list: if isStaff();
      allow write: if isAdmin(); // escrita normal é pela Function de agregação
    }
  }
}

================================
CLOUD FUNCTIONS (Node) — OBRIGATÓRIAS
================================
Criar as seguintes **Callable HTTPS Functions**:

1) `setUserRole({ uid, role })` (admin-only)
   - Seta **custom claims** `role` no Auth.
   - Atualiza `profiles/{uid}.role`.
   - Somente admin pode chamar (checar claim de quem chama).

2) `createEvaluation({ clientId, assessorId, dataAvaliacao, observacoes, responses:[{dimensionId, score}] })` (assessor)
   - Verifica que quem chama tem role 'assessor' e que `assessorId` pertence ao `auth.uid`.
   - Calcula média (2 casas), cria **evaluation** e os 8 **responses** em **transação/batch**.
   - Dispara atualização de agregados (chamar função #4 ou publicar mensagem para fila).

3) `searchClients({ q, limit=50 })` (assessor + staff)
   - Normaliza `q` para minúsculas/sem acento.
   - Faz **prefix search** em `clients` por `nome_insensitivo` com `startAt(q)`/`endAt(q+'\uf8ff')`.
   - Retorna apenas `{id, nome}` (sem e-mail/telefone/empresa).

4) `getAggregates({ from, to, clientId?, assessorId? })` (staff)
   - Retorna KPIs, séries mensais, médias por assessor/cliente e **heatmap Cliente × Dimensão**.
   - Usa `monthly_aggregates` quando possível; complementar com consultas pontuais.

5) `exportAggregates({ from, to, clientId?, assessorId?, format:'csv'|'xlsx' })` (staff)
   - Gera arquivo no **Cloud Storage** (`exports/…`) e retorna **URL assinada**.

6) `seedDevData()` (admin)
   - Popula `dimensions` (8 fixas), 5 clientes e 4 assessores; cria ~30 avaliações aleatórias (últimos 3 meses).

**Trigger opcional (onWrite em evaluations):**
- Atualiza/insere o doc correspondente em `monthly_aggregates` (por mês/cliente/assessor).

================================
ROTAS / FLUXOS
================================
/login:
- Sign up / Sign in (Firebase Auth). Após login, consultar `profiles/{uid}` e/ou claims para redirecionar conforme papel.

/avaliar (assessor):
- Form: Cliente (autocomplete via **Function `searchClients`**), Data (default hoje), Observações (textarea),
  e 8 radios 1–5 (obrigatórios) com labels das dimensões.
- Submit chama **Function `createEvaluation`**; exibir toast de sucesso e **resumo com média (2 casas)**.
- **Não renderizar** listagens/tabelas para assessor (form-only).

/painel (cs/diretoria/admin):
- Filtros (persistir em URL): intervalo de datas (ou seletor de mês), Cliente, Assessor.
- KPIs: Health médio (período), nº de avaliações, Top 3 clientes (↑), Top 3 dimensões (↓).
- Gráficos:
  - Linha: **Health médio por mês** (últimos 12) — preferir `monthly_aggregates`.
  - Barras: **média por assessor** (considerar filtros).
  - Heatmap **Cliente × Dimensão** (1 vermelho → 5 verde; exibir valor na célula).
- Tabela: avaliações recentes (cliente, assessor, data, média, observações) com paginação (limit/orderBy/startAfter).
- Botões de **Exportar CSV/XLSX** → chama `exportAggregates` e faz download da URL assinada.

/clientes (cs/admin):
- CRUD com busca/ordenar/paginar; detalhe com evolução mensal e heatmap do cliente.

/assessores (admin):
- Listar, ativar/inativar, vincular assessor ⇄ userId; exibir contagem/média no período.

/dimensoes (leitura):
- Lista fixa; permitir reordenar “ordem”.

================================
MÉTRICAS / CÁLCULOS
================================
- Média da avaliação = média simples das 8 notas (2 casas).
- Health médio por mês = agrupar por ano-mês de `dataAvaliacao`.
- Médias por assessor e por cliente respeitando filtros.

================================
ÍNDICES FIRESTORE (console ou firestore.indexes.json)
================================
- **clients**: single-field index em `nome_insensitivo` (ASC) para autocomplete.
- **evaluations**:
  - composto: `clientId` (ASC), `dataAvaliacao` (DESC)
  - composto: `assessorId` (ASC), `dataAvaliacao` (DESC)
- **monthly_aggregates**:
  - single-field em `mes` (ASC), e se necessário compostos por (`mes`,`clientId`) e (`mes`,`assessorId`).

================================
SEEDS (para teste via Cloud Function)
================================
- Executar `seedDevData()` para criar 5 clientes e 4 assessores; preencher `dimensions` e ~30 avaliações (últimos 3 meses).

================================
README (gerar no projeto)
================================
- Como configurar Firebase (Auth, Firestore, Functions, Storage) e **deploy**.
- Como setar **custom claims**:
  - `setUserRole({ uid, role })` (admin) e fluxos de promoção/demotion.
- Como publicar as **Rules** no Firestore.
- Como rodar/depurar as **Cloud Functions** localmente.
- Como criar **índices** e interpretar erros de “falta de índice”.
- Estrutura de pastas (pages, components, services).
- Como trocar tema (tokens) e ajustar gráficos.
_LOCATION=us-central1

# Configurações de e-mail (opcional)
SMTP_SERVER=smtp.gmail.com
SMTP_PORT=587
SMTP_USERNAME=your-email@gmail.com
SMTP_PASSWORD=your-app-password

# Configurações do Slack (opcional)
SLACK_WEBHOOK_URL=https://hooks.slack.com/services/your/webhook/url

# Configurações de upload
UPLOAD_DIR=./uploads
MAX_FILE_SIZE=10485760

# Configurações de cache
REDIS_URL=redis://localhost:6379 